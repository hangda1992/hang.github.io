{"meta":{"title":"航的博客","subtitle":null,"description":null,"author":"hang","url":"http://hangda1992.github.io","root":"/"},"pages":[],"posts":[{"title":"python2和python3字符区别","slug":"python2和python3字符区别","date":"2019-03-13T11:35:52.000Z","updated":"2019-03-13T13:32:41.348Z","comments":true,"path":"2019/03/13/python2和python3字符区别/","link":"","permalink":"http://hangda1992.github.io/2019/03/13/python2和python3字符区别/","excerpt":"​ python2字符有str和unicode的概念 ​ python3字符有str和byte的概念 ​ 在字符的问题上，相对而言区别很大，不认真去对比都不知道怎么用的。并且面试也会经常问到这一类问题","text":"​ python2字符有str和unicode的概念 ​ python3字符有str和byte的概念 ​ 在字符的问题上，相对而言区别很大，不认真去对比都不知道怎么用的。并且面试也会经常问到这一类问题 Python2字符Python2存在的类型 unicode类型 12&gt;&gt;&gt; print type(u\"中文\")&lt;type 'unicode'&gt; str类型 12&gt;&gt;&gt; print type(\"中文\")&lt;type 'str'&gt; Python2 unicode和str在Python2中并没有byte的概念，只有str和unicode的区别，所以来研究一下这两者之间的区别 123graph LR A(gb2312)--decode:解码--&gt;B(unicode); B--encode:编码--&gt;C(utf-8); str显示 12345&gt;&gt;&gt; h = '航'&gt;&gt;&gt; type(h)&lt;type 'str'&gt;&gt;&gt;&gt; repr(h)\"'\\\\xba\\\\xbd'\" unicode显示 123456&gt;&gt;&gt; h = u'航'&gt;&gt;&gt; type(h)&lt;type 'unicode'&gt;&gt;&gt;&gt; repr(h)\"u'\\\\u822a'\"&gt;&gt;&gt; unicode转utf-8字符串 123&gt;&gt;&gt; h = u\"航\"&gt;&gt;&gt; h.encode(\"utf-8\")'\\xe8\\x88\\xaa' 字符转unicode，windows系统下默认格式是gb2312 123&gt;&gt;&gt; h = \"航\"&gt;&gt;&gt; h.decode(\"gb2312\")u'\\u822a' Python3字符Python3 str和bytePython3中加入了Byte的概念，相对字符而言是一个完善。python3默认字符格式是unicode类型 unicode 就是str 123456&gt;&gt;&gt; h = \"航\"&gt;&gt;&gt; type(h)&lt;class 'str'&gt;&gt;&gt;&gt; h = u\"航\"&gt;&gt;&gt; type(h)&lt;class 'str'&gt; str转byte 123graph LR A(str)--encode:编码--&gt;B(byte); B--decode:解码--&gt;C(str); 12345678# str--&gt;byte&gt;&gt;&gt; h = \"航\"&gt;&gt;&gt; h.encode()b'\\xe8\\x88\\xaa'# byte--&gt;str&gt;&gt;&gt; b'\\xe8\\x88\\xaa'.decode()'航' encode不同格式的编码占用的内存空间也不一样 12345678910111213data = u\"航\"print(repr(data))print(data.encode())print(repr(data.encode(\"utf-8\")))print(data.encode(\"gbk\"))print(data.encode(\"gb2312\"))# 输出结果'航'b'\\xe8\\x88\\xaa'b'\\xe8\\x88\\xaa'b'\\xba\\xbd'b'\\xba\\xbd' 计算长度，不同类型长度不同 12len(\"航\") # 1len(\"航\".encode()) # 3","categories":[{"name":"python","slug":"python","permalink":"http://hangda1992.github.io/categories/python/"},{"name":"python基础","slug":"python/python基础","permalink":"http://hangda1992.github.io/categories/python/python基础/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://hangda1992.github.io/tags/Python/"}]},{"title":"Deepin翻墙-shadowsocks加密方式chacha20-ietf-poly1305","slug":"Deepin翻墙-shadowsocks加密方式chacha20-ietf-poly1305","date":"2019-02-22T11:36:11.000Z","updated":"2019-03-13T13:29:10.690Z","comments":true,"path":"2019/02/22/Deepin翻墙-shadowsocks加密方式chacha20-ietf-poly1305/","link":"","permalink":"http://hangda1992.github.io/2019/02/22/Deepin翻墙-shadowsocks加密方式chacha20-ietf-poly1305/","excerpt":"说明：使用Deepin 15.8系统，深度商店shadowsocks软件支持的加密方式有限，由于我购买的账号必须使用chacha20-ietf-poly1305加密方式，故而需要自己寻找方可用的翻墙软件，shadowsocks-libev就支持chacha20-ietf-poly1305加密方式","text":"说明：使用Deepin 15.8系统，深度商店shadowsocks软件支持的加密方式有限，由于我购买的账号必须使用chacha20-ietf-poly1305加密方式，故而需要自己寻找方可用的翻墙软件，shadowsocks-libev就支持chacha20-ietf-poly1305加密方式 安装shadowsocks-libev 12sudo apt updatesudo apt install shadowsocks-libev 配置shadowsocks 1234# 备份配置文件,养成一个好习惯cp /etc/shadowsocks-libev/config.json /etc/shadowsocks-libev/config.json.bak# 修改配置文件vi /etc/shadowsocks-libev/config.json 配置文件 12345678910&#123; \"server\":\"xxx\", \"server_port\":xxx, \"local_port\":xxx, \"password\":\"xxx\", \"timeout\":60, \"method\":\"chacha20-ietf-poly1305\", \"fast_open\": false, \"workers\": 1&#125; 启动服务并设置开机启动项 1234567891011121314# 启动服务,并后台运行ss-local -c /etc/shadowsocks-libev/config.json &amp;# 开机启动# deepin15.8桌面版本没有/etc/rc.local文件,手动创建一个/etc/rc.localvi /etc/rc.local# 添加如下内容:#!/bin/bash# rc.local config file created by usess-local -c /etc/shadowsocks-libev/config.json &amp;exit 0 系统代理配置Deepin自带系统代理功能,打开系统控制中心-&gt;网络-&gt;系统代理-&gt;手动 12socket代理:127.0.0.1端口:1080","categories":[{"name":"Linux","slug":"Linux","permalink":"http://hangda1992.github.io/categories/Linux/"},{"name":"Deepin","slug":"Linux/Deepin","permalink":"http://hangda1992.github.io/categories/Linux/Deepin/"}],"tags":[{"name":"Deepin","slug":"Deepin","permalink":"http://hangda1992.github.io/tags/Deepin/"},{"name":"翻墙","slug":"翻墙","permalink":"http://hangda1992.github.io/tags/翻墙/"}]},{"title":"序列化-请求参数验证","slug":"序列化-请求参数验证","date":"2018-11-26T11:28:46.000Z","updated":"2019-03-13T13:29:48.901Z","comments":true,"path":"2018/11/26/序列化-请求参数验证/","link":"","permalink":"http://hangda1992.github.io/2018/11/26/序列化-请求参数验证/","excerpt":"误解：之前刚看序列号的时候总觉得这个功能没有啥用，django返回的格式序列化，感觉自己也能做到这点，没有必要用到这序列化的功能，浪费时间写 正解：序列化的一个重要功能能够对请求的参数进行验证","text":"误解：之前刚看序列号的时候总觉得这个功能没有啥用，django返回的格式序列化，感觉自己也能做到这点，没有必要用到这序列化的功能，浪费时间写 正解：序列化的一个重要功能能够对请求的参数进行验证 建立django项目 环境 123python== 3.5django==1.11djangorestframework==3.90 创建虚拟环境 1234virtualenv envsource env/bin/activatepip install djangopip install djangorestframework 建立工程 123django-admin startproject tutorialcd tutorialpython manage.py startapp snippets 配置djangosettings.py 12345INSTALLED_APPS = ( ... &apos;rest_framework&apos;, &apos;snippets.apps.SnippetsConfig&apos;,) 编写序列化类在appsnippets下面创建serializers.py用于序列化类，作用：验证请求参数为id并且最大值设定为212345from rest_framework import serializersclass SnippetSerializer(serializers.Serializer): id = serializers.IntegerField(max_value=2) 编写视图视图函数用于处理请求信息，路径snippets\\views.py 123456789101112131415161718192021222324252627from rest_framework.parsers import JSONParserfrom snippets.serializers import SnippetSerializerfrom django.http import HttpResponse, JsonResponsefrom django.views.decorators.csrf import csrf_exempt# Create your views here.@csrf_exemptdef test001(request): if request.method == &apos;POST&apos;: # 用于获取request对象中的post求情参数 data = JSONParser().parse(request) # 序列化data参数，这里data必须是json格式 serializer = SnippetSerializer(data=data) # 判断是否满足序列化条件 if serializer.is_valid(): return JsonResponse(serializer.data, status=201) return JsonResponse(serializer.errors, status=400) if request.method == &apos;GET&apos;: # 用于获取request对象中的get请求参数 data = request.GET.dict() # 序列化data参数，这里data必须是json格式 serializer = SnippetSerializer(data=data) if serializer.is_valid(): return JsonResponse(serializer.data, status=201) return JsonResponse(serializer.errors, status=400) 配置路由设置一个测试的路由，路径tutorial\\urls.py12345678from django.conf.urls import urlfrom django.contrib import adminfrom snippets import viewsurlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^test&apos;, views.test001),] 整体目录结构1234567891011121314151617.\\snippets.\\snippets\\migrations\\__init__.py.\\snippets\\admin.py.\\snippets\\apps.py.\\snippets\\models.py.\\snippets\\serializers.py.\\snippets\\tests.py.\\snippets\\views.py.\\snippets\\__init__.py.\\snippets\\migrations.\\tutorial.\\tutorial\\settings.py.\\tutorial\\urls.py.\\tutorial\\wsgi.py.\\tutorial\\__init__.py.\\db.sqlite3.\\manage.py 测试序列化效果POST\\http://127.0.0.1:8000/test 正确传参参数：123&#123; \"id\": 1&#125; 返回值：123&#123; \"id\": 1&#125; 错误（数值大于2）参数：123&#123; \"id\": 3&#125; 返回值：12345&#123; \"id\": [ \"Ensure this value is less than or equal to 2.\" ]&#125; GET\\http://127.0.0.1:8000/test 正确传参http://127.0.0.1:8000/test?id=1返回值： 123&#123; \"id\": 1&#125; 错误传参http://127.0.0.1:8000/test?id=3返回值： 12345&#123; \"id\": [ \"Ensure this value is less than or equal to 2.\" ]&#125;","categories":[{"name":"Python","slug":"Python","permalink":"http://hangda1992.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"http://hangda1992.github.io/categories/Python/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://hangda1992.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://hangda1992.github.io/tags/Django/"}]},{"title":"Django如何实现文件下载","slug":"Django如何实现文件下载","date":"2018-11-15T11:21:22.000Z","updated":"2019-03-13T13:29:34.734Z","comments":true,"path":"2018/11/15/Django如何实现文件下载/","link":"","permalink":"http://hangda1992.github.io/2018/11/15/Django如何实现文件下载/","excerpt":"说明： Django 带有下载文件模块FileResponse，利用这个模块可以实现浏览器下载功能","text":"说明： Django 带有下载文件模块FileResponse，利用这个模块可以实现浏览器下载功能 1.思路123文件，让用户下载 - a标签+静态文件 - 设置响应头(django如何实现文件下载） 2. a标签实现1&lt;a href=&quot;/static/xxx.xlsx&quot;&gt;下载模板&lt;/a&gt; 3. 设置响应头 方法一：使用HttpResponse 1234567from django.shortcuts import HttpResponse def file_down(request): file=open('/home/amarsoft/download/example.tar.gz','rb') response =HttpResponse(file) response['Content-Type']='application/octet-stream' response['Content-Disposition']='attachment;filename=\"example.tar.gz\"' return response 方法二：使用StreamingHttpResponse 1234567from django.http import StreamingHttpResponse def file_down(request): file=open('/home/amarsoft/download/example.tar.gz','rb') response =StreamingHttpResponse(file) response['Content-Type']='application/octet-stream' response['Content-Disposition']='attachment;filename=\"example.tar.gz\"' return response 方法三：使用FileResponse 函数内部做了分块传输，大小为4096避免内存暂用过大 1234567from django.http import FileResponse def file_down(request): file=open('/home/amarsoft/download/example.tar.gz','rb') response =FileResponse(file) response['Content-Type']='application/octet-stream' response['Content-Disposition']='attachment;filename=\"example.tar.gz\"' return response 4. 项目案例： 增加URL： 12345urlpatterns = [ url(r'^stark/crm/login/', crm_views.login,name='crm_login'), url(r'^stark/crm/index/', crm_views.index,name='crm_index'), url(r'^stark/crm/Download/', crm_views.download,name='crm_download'),] 编写download视图函数： 123456def download(request): file=open('static/xlsx/xlsx_file.xlsx','rb') response =FileResponse(file) response['Content-Type']='application/octet-stream' response['Content-Disposition']='attachment;filename=\"xlsx_file.xlsx\"' return response 前端页面反向解析URL 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;批量导入客户数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;批量导入&lt;/h2&gt;&lt;form action=\"\"&gt; &lt;a href=\"&#123;% url 'crm_download' %&#125;\"&gt;下载模板&lt;/a&gt; &lt;p&gt;&lt;input type=\"file\" name=\"xsfile\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"提交\"&gt;&lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 转载至：https://www.cnblogs.com/supery007/p/8146035.html","categories":[{"name":"Python","slug":"Python","permalink":"http://hangda1992.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"http://hangda1992.github.io/categories/Python/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://hangda1992.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://hangda1992.github.io/tags/Django/"}]},{"title":"Django创建流程","slug":"Django创建流程","date":"2018-11-14T11:13:04.000Z","updated":"2019-03-13T13:29:23.821Z","comments":true,"path":"2018/11/14/Django创建流程/","link":"","permalink":"http://hangda1992.github.io/2018/11/14/Django创建流程/","excerpt":"说明：Django简单的创建步骤","text":"说明：Django简单的创建步骤 前提：需要安装Python，不晓得如何安装可自行谷歌百度 安装 1pip install django==1.11 # 版本号 创建django工程 1django-admin.py startproject project_name 创建APP 1django-admin.py startapp app_name 创建数据库 123456# Django 1.6.x 及以下python manage.py syncdb # Django 1.7 及以上的版本需要用以下命令python manage.py makemigrationspython manage.py migrate 创建admin用户 1python manage.py createsuperuser","categories":[{"name":"Python","slug":"Python","permalink":"http://hangda1992.github.io/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"http://hangda1992.github.io/categories/Python/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://hangda1992.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://hangda1992.github.io/tags/Django/"}]}]}